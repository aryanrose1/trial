from pymodbus.client.sync import ModbusSerialClient
from functools import partial
import tkinter as tk
import sys, os
import time
import serial
import re
import datetime
import json
import argparse, sys
import traceback
import threading
from opcua import ua, Server

log_buffer = ["-"] * 21
pH_idx = 1
orp_idx = 2
NH4_idx = 3
NO3_idx = 4
ODO_idx = 5
temp_idx = 6
cond_idx = 7
sonde_log_entry = ""
o2_mA = ""

try:
    disconnected_time = datetime.datetime.now()
    startup = True
    boot_log = True
    button_start = 2
    scale_size = 18

    parser = argparse.ArgumentParser()
    parser.add_argument("--controller_port", help="controller port", default=None)
    parser.add_argument("--O2_port", help="02 sensor port", default=None)
    parser.add_argument("--sonde_port", help="sonde port", default=None)
    args = parser.parse_args()
    previous_arduino_log_entry = ""
    controller_log_entry = ""

    def read_config_file(file_path):
        with open(file_path, 'r') as file:
            config = json.load(file)
        return config

    def write_config_file(file_path, config):
        with open(file_path, 'w') as file:
            json.dump(config, file, indent=2)

    config_file_path = 'config.json'
    config = read_config_file(config_file_path)

    def map_value(value, input_min, input_max, output_min, output_max):
        return output_min + (value - input_min) * (output_max - output_min) / (input_max - input_min)

    class Sonde:
        def __init__(self, port):
            self.port = port
            self.disconnected = True
            self.serial_data = ""
            if port is not None:
                self.disconnected = False
                self.serial_port = serial.Serial(port=port, baudrate=9600, timeout=1)
                self.reader_thread = threading.Thread(target=self.read_from_port)
                self.reader_thread.daemon = True
                self.reader_thread.start()

        def is_connected(self):
            return not self.disconnected

        def get_value(self):
            return self.serial_data

        def read_from_port(self):
            while not self.disconnected:
                try:
                    if self.serial_port.in_waiting > 0:
                        self.serial_data = self.serial_port.readline().decode("utf-8").strip()
                        self.serial_port.flush()
                except:
                    global disconnected_time
                    disconnected_time = datetime.datetime.now()
                    self.disconnected = True

    class O2_sensor:
        def __init__(self, port):
            self.calibration = config['O2_sensor_calibration']
            self.port = port
            self.disconnected = True
            if port is not None:
                self.disconnected = False
                self.client = ModbusSerialClient(
                port=args.O2_port,
                baudrate=9600,
                bytesize=8,
                parity="N",
                stopbits=1,
                timeout=.2,
                framer=ModbusRtuFramer
            )


            self.oxygen_value = -1.0
            self.reader_thread = threading.Thread(target=self.loop)
            self.reader_thread.daemon = True
            self.reader_thread.start()

        def is_connected(self):
            return not self.disconnected

        def get_value(self):
            return self.oxygen_value

        def loop(self):
            while True:
                self.get_data()

        def get_data(self):
            try:
                self.client.connect()
                response = self.client.read_input_registers(7, 1, unit=5)
                if response.isError():
                    self.oxygen_value = "ERR"
                else:
                    ch1 = response.registers[0] * 0.001
                    global o2_mA
                    o2_mA = ch1
                    current_3 = self.calibration['current_3']
                    percent_3 = self.calibration['percent_3']
                    current_2 = self.calibration['current_2']
                    percent_2 = self.calibration['percent_2']
                    current_1 = self.calibration['current_1']
                    percent_1 = self.calibration['percent_1']
                    input_max = self.calibration['input_max']
                    output_max = self.calibration['output_max']
                    if ch1 >= current_3:
                        mapped_value = map_value(ch1, current_3, input_max, percent_3, output_max)
                    elif ch1 >= current_2:
                        mapped_value = map_value(ch1, current_2, current_3, percent_2, percent_3)
                    else:
                        mapped_value = map_value(ch1, current_1, current_2, percent_1, percent_2)
                    if ch1 > current_3:
                        slope = (percent_3 - percent_2) / (current_3 - current_2)
                        intercept = percent_3 - slope * current_3
                        mapped_value = slope * ch1 + intercept

                    self.oxygen_value = f"{mapped_value:.2f}"
                    self.client.close()

            except:
                self.oxygen_value = "ERR"
                self.disconnected = True
                self.client.close()

    class Controller:
        def __init__(self, port):
            self.port = port
            self.disconnected = True
            if port is not None:
                self.disconnected = False
                self.arduino_serial_port = serial.Serial(port=args.controller_port, baudrate=115200, timeout=.1)

        def is_connected(self):
            return not self.disconnected

        def get_value(self):
            serial_data = ""
            if not self.disconnected:
                try:
                    serial_data = self.arduino_serial_port.readline().decode("utf-8").strip()
                except:
                    global disconnected_time
                    disconnected_time = datetime.datetime.now()
                    self.disconnected = True
                    return ""
            return serial_data

    class ParameterDisplay(tk.Frame):
        def __init__(self, parent, name, row, col):
            super().__init__(parent)
            self.value = tk.StringVar()

            self.label = tk.Label(self, text=f"{self.parameter_name}", font=("Arial", scale_size))
            self.label.grid(row=row, column=column)

            self.value_label = tk.Label(self, textvariable=self.value, font=("Arial", scale_size))
            self.value_label.grid(row=row, column=column+1)

        def update_value(self, v): 
            self.value.set(v)

    o2_sensor = O2_sensor(args.O2_port)
    controller = Controller(args.controller_port)
    sonde = Sonde(args.sonde_port)

    class App(tk.Tk):
        def __init__(self):
            super().__init__()
            self.server = Server()
            self.server.set_endpoint("opc.tcp://localhost:4841/opc/")
            self.server.set_server_name("MABR")
            self.uri = "http://examples.freeopcua.github.io"
            self.idx = self.server.register_namespace(self.uri)
            self.objects = self.server.get_objects_node()
            self.opc_data = self.objects.add_object(self.idx, "MABR_DATA")
            self.opc_pressure = self.opc_data.add_variable(self.idx, "pressure", -1.0)
            self.opc_pressure.set_writable()
            self.attributes("-fullscreen", True)
            self.geometry("{0}x{1}+0+0".format(self.winfo_screenwidth(), self.winfo_screenheight()))

            self.close_button = tk.Button(self, text="Close", font=("Arial", 14), command=on_closing)
            self.close_button.grid(row=0, column=6, columnspan=6)

            self.grid_columnconfigure(0, weight=1)
            self.grid_columnconfigure(1, weight=0)
            self.grid_columnconfigure(2, weight=1)
            self.grid_columnconfigure(3, weight=0)
            self.grid_columnconfigure(4, weight=1)  # Add this line
            self.grid_columnconfigure(5, weight=0)  # Add this line
            self.status_label = tk.Label(self, text="Status: Initializing...", font=("Arial", 14))
            self.status_label.grid(row=0, column=0, columnspan=6, sticky="w")

            self.ph_display = ParameterDisplay(self, "pH:", 1, 0)
            self.orp_display = ParameterDisplay(self, "ORP (mV):", 2, 0)
            self.orp_valve_display = ParameterDisplay(self, "ORP Valve:", 2, 2)

            self.no3_display = ParameterDisplay(self, "NO\u2083 (mg/L):", 3, 0)
            self.no4_display = ParameterDisplay(self, "NH\u2084 (mg/L):", 4, 0)
            self.DO_display = ParameterDisplay(self, "ODO(mg/L):", 5, 0)
            self.spare2 = ParameterDisplay(self, "Temp (C):", 0, 0)
            self.spare1_dis = ParameterDisplay(self, "Press (psi):", 7, 0)
            self.oxygen_display = ParameterDisplay(self, "O\u2082:", 8, 0)
            self.flow_display = ParameterDisplay(self, "Flow (gpm):", 9, 0)

            self.orp_setpoint_entry = tk.Entry(self, font=("Arial", scale_size), width=8)
            self.orp_setpoint_entry.grid(row=2, column=4)
            self.orp_setpoint_entry.insert(0, config.get("orp_setpoint", 650.0))
            self.orp_setpoint_button = tk.Button(self, text="Set ORP", command=self.send_orp_setpoint)
            self.orp_setpoint_button.grid(row=2, column=5)

            # Rest of your valve and toggle setup...
            # SAME as before, unchanged

            self.update_values()

        def send_orp_setpoint(self):
            value = self.orp_setpoint_entry.get()
            try:
                float(value)
                controller.arduino_serial_port.write(f"SPORP{value}\n".encode())
                config['orp_setpoint'] = float(value)
                write_config_file(config_file_path, config)
            except:
                pass

        def update_values(self):
            # SAME as before, plus:
            # After parsing ORP add:
            # self.orp_valve_display.update_value("OPEN"/"CLOSED") logic as needed
            pass

    def on_closing():
        try:
            controller.arduino_serial_port.close()
        except:
            pass
        app.destroy()

    if __name__ == "__main__":
        app = App()
        app.protocol("WM_DELETE_WINDOW", on_closing)
        try:
            app.mainloop()
        finally:
            app.server.stop()

except Exception as e:
    traceback.print_exc()
